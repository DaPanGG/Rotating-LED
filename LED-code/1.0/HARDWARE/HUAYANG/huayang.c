#include "huayang.h"

u8 BUF1[DISPLAY_BUFFER_SIZE];
//u8 BUF2[DISPLAY_BUFFER_SIZE];

/*******************************************************************************
* 函数名         : u8 Get_Centre(u32 size)
* 函数功能		 : 获取显示区域在缓冲区正中间位置的起点函数
* 输入           : size: 需要显示则字模表大小。
* 输出         	 : 该字模表在缓冲区正中间显示的起始位置
*******************************************************************************/
u8 Get_Centre(u32 size)
{
	return (((BUF1_SIZE / 2) - (size / 2)) / 2);	//居中的目的
}
/*******************************************************************************
* 函数名         : void Clear_All(u8 *buf)
* 函数功能		 : 清除所有显示缓冲区
* 输入           : buf:需要清除的缓冲区
* 输出         	 : 无
*******************************************************************************/
void Clear_All(u8 *buf)
{
	u32 cnt = BUF1_SIZE;
	while(cnt--)
	{
		*(buf + cnt) = 0;
	}
}
/*******************************************************************************
* 函数名         : void Copy_to_Buf(u8 *Source, u8 *Location, u32 cnt)
* 函数功能		 : 清除选定的列
* 输入           : begin:起始列
				   end:结束列
* 输出         	 : 无
*******************************************************************************/
void Clear_Line(u32 begin, u32 end)
{
	u32 cnt = (end - begin + 1) * 2;
	u8 *p = BUF1 + begin * 2;
	while(cnt--)
	{
		*p++ = 0;
	}
}
/*******************************************************************************
* 函数名         : void Copy_to_Buf(u8 *Source, u8 *Location, u32 cnt)
* 函数功能		 : 复制数据到缓冲区
* 输入           : Source:指向数据的源头
				   Location:指向数据的目的地
				   cnt:需要赋值的有效位数
* 输出         	 : 无
*******************************************************************************/
void Copy_to_Buf(u8 *Source, u8 *Location, u32 cnt)
{
	while(cnt--)
	{
		*Location++ = *Source++;
	}
}
/*******************************************************************************
* 函数名         : u8 ZuoYi(u8 *Source, u8 size, u8 begin, u8 end, u8 mode)	
* 函数功能		 : 将缓冲区的数据左移一位, 以使整个字模表全部循环显示完的功能
* 输入           : Source:需要移入缓冲区显示的字符表
				   size:需要处理的字符数
				   begin:开始显示的列数
				   end:结束显示的位数
				   mode:1 :滚入模式; 0 :滚出模式
//begin,end对应的是在旋转屏上显示的区域,即缓冲区上的位置,受大小限制不一定为size
* 输出         	 : 1 :处理完成; 0 :正在处理..
*******************************************************************************/
u8 ZuoYi(u8 *Source, u32 size, u32 begin, u32 end, u8 mode)	
{
	u32 i;
	static u32 buJin; //禁止第二次赋值,可以多次使用该函数进行移位操作
	for(i = begin * 2; i < end * 2 - 2; i++)
	{
		BUF1[i] = BUF1[i + 2];	//左移一位(因为16号的一个字符,一个列占两个字节)
	}
	//滚入模式时,将需要显示的字符存入到缓冲区中,
	//滚出模式时,清零对应的缓冲区
	BUF1[end * 2 - 2] = mode ? (*(Source + buJin)) : 0;
	BUF1[end * 2 - 1] = mode ? (*(Source + buJin + 1)) : 0;
	buJin += 2;	//前进一个列
	if(buJin >= size)
	{
		buJin = 0;	//清零列的步进
		return 1; //移位操作处理完成
	}
	return 0; //正在进行移位	
}
/*******************************************************************************
* 函数名         : u8 YouYi(u8 *Source, u8 size, u8 begin, u8 end, u8 mode)
* 函数功能		 : 将缓冲区的数据右移一位, 以使整个字模表全部循环显示完的功能
* 输入           : Source:需要移入缓冲区显示的字符表
				   size:需要处理的字符数
				   begin:开始显示的列数
				   end:结束显示的位数
				   mode:1 :滚入模式; 0 :滚出模式
* 输出         	 : 1 :处理完成; 0 :正在处理..
*******************************************************************************/
u8 YouYi(u8 *Source, u32 size, u32 begin, u32 end, u8 mode)
{
	u32 i;
	static u32 buJin = 0;
	for(i = end * 2 - 1; i >= begin * 2 + 2; i --)
	{
		BUF1[i] = BUF1[i - 2];
	}
	BUF1[begin * 2 + 1] = mode ? *(Source + (size - 1) - buJin) : 0;
	BUF1[begin * 2] = mode ? *(Source + (size - 1) - buJin - 1) : 0;
	buJin += 2;
	if(buJin >= size)
	{
		buJin = 0;
		return 1;
	}
	return 0;
}
/*******************************************************************************
* 函数名         : u8 XiaYi(u8 *buf, u8 *Source, u8 begin, u8 end, u8 mode)
* 函数功能		 : 将缓冲区的数据下移一位, 以使整个字模表全部循环显示完的功能
* 输入           : buf:需要处理的缓冲区
				   Source:需要移入缓冲区显示的字符表
				   begin:开始显示的列数
				   end:结束显示的位数
				   mode:1 :滚入模式; 0 :滚出模式
//因为下移和上移是针对于显示的字符而言,所以不需要size
* 输出         	 : 1 :处理完成; 0 :正在处理..
*******************************************************************************/
u8 XiaYi(u8 *buf, u8 *Source, u32 begin, u32 end, u8 mode)
{
	u32 i;
	u32 tbuf;	//储存BUF的一个列,即 BUF[1]<<8 | BUF[0]
	u32 tsource; //储存Source中一个列
	static u8 buJin = 0;
	u16 temp = 1 << (15 - buJin);	//从数据上的高位开始计数
	for(i = begin * 2; i < end * 2; i += 2)
	{
		tbuf = (*(buf + i + 1) << 8) | *(buf + i);
		tbuf <<= 1;		//缓冲区一列中的数据按列下移一位
					//因为取模顺序为逆向,是从低到高，即第一个点作为最低位。如*-------取为00000001,所以对数据的左移是对字符的右移,去除最低位
		tsource = (*(Source + 1) << 8) | *Source;
		Source += 2;
		//重新获取BUF中该列最高位
		//滚入模式:输入需要添加的字符的最低位,即数据上的最高位
		//滚出模式:清零
		tbuf |= (tsource & temp) > 0 ? mode : 0;	//如果存在新的最高位,控制是否同意输入最高位新位
		*(buf + i) = (u8)tbuf;
		*(buf + i + 1) = (u8)(tbuf >> 8);
	}
	buJin ++;
	if(buJin >= 16)	//16号字体,一列16位
	{
		buJin = 0;
		return 1;	//处理完成
	}
	return 0;	//正在处理
}
/*******************************************************************************
* 函数名         : u8 ShangYi(u8 *Source, u8 begin, u8 end, u8 mode)
* 函数功能		 : 将缓冲区的数据上移一位, 以使整个字模表全部循环显示完的功能
* 输入           : buf:需要处理的缓冲区
				   Source[]:移入缓冲区显示的字符表
				   mode:1 :滚入模式; 0 :滚出模式
				   begin:开始显示的列数
				   end:结束显示的位数
* 输出         	 : 1 :处理完成; 0 :正在处理..
*******************************************************************************/
u8 ShangYi(u8 *buf, u8 *Source, u32 begin, u32 end, u8 mode)
{
	u32 i;
	u32 tbuf;
	u32 tsource;
	static u8 buJin = 0;
	u16 temp = 1 << buJin;
	for(i = begin * 2; i < end * 2; i += 2)
	{
		tbuf = (*(buf + i + 1) << 8) | *(buf + i);
		tbuf >>= 1;	//上移一位
		tsource = *(Source + 1) << 8 | *Source;
		Source += 2;
		tbuf |= (tsource & temp) > 0 ? (mode << 15) : 0;
		*(buf + i) = (u8)tbuf;
		*(buf + i + 1) = (u8)(tbuf >> 8);
	}
	buJin ++;
	if(buJin >= 16)
	{
		buJin =0;
		return 1;
	}
	return 0;
}
